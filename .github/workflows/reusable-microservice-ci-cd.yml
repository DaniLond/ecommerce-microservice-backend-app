# Reusable Workflow for Microservice CI/CD
# Este workflow implementa todas las mejores prÃ¡cticas DevOps:
# - Build & Test con cobertura
# - SonarQube para anÃ¡lisis estÃ¡tico
# - Trivy para escaneo de vulnerabilidades
# - Versionado semÃ¡ntico automÃ¡tico
# - Deploy multi-ambiente (dev/staging/prod)
# - Rollback automÃ¡tico en caso de fallo
# - Notificaciones de estado

name: Reusable Microservice CI/CD

on:
  workflow_call:
    inputs:
      service_name:
        required: true
        type: string
        description: 'Name of the microservice (e.g., user-service)'
      service_port:
        required: true
        type: string
        description: 'Port of the microservice'
      context_path:
        required: true
        type: string
        description: 'Context path (e.g., /user-service or /)'
      environment:
        required: true
        type: string
        description: 'Target environment: development, staging, production'
      requires_approval:
        required: false
        type: boolean
        default: false
        description: 'Require manual approval before deployment'
    secrets:
      AZURE_CREDENTIALS:
        required: true
      ACR_LOGIN_SERVER:
        required: true
      ACR_USERNAME:
        required: true
      ACR_PASSWORD:
        required: true
      SONAR_TOKEN:
        required: false
      SLACK_WEBHOOK_URL:
        required: false
      KUBE_CONFIG:
        required: true

env:
  ACR_NAME: ecommerceacr1202
  AKS_CLUSTER: ecommerce-dev-aks
  AKS_RESOURCE_GROUP: ecommerce-dev-rg
  JAVA_VERSION: '17'
  MAVEN_OPTS: -Xmx512m

jobs:
  # ============================================
  # JOB 1: BUILD & TEST
  # ============================================
  build-and-test:
    name: ðŸ”¨ Build & Test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.semantic-version.outputs.version }}
      
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for semantic versioning
          
      - name: â˜• Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'
          
      - name: ðŸ“¦ Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-
            
      - name: ðŸ”¢ Generate Semantic Version
        id: semantic-version
        run: |
          # ImplementaciÃ³n de versionado semÃ¡ntico basado en conventional commits
          # v1.0.0 -> v1.0.1 (patch), v1.1.0 (minor), v2.0.0 (major)
          
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Last tag: $LAST_TAG"
          
          # Obtener commits desde el Ãºltimo tag
          COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s")
          
          # Determinar tipo de bump
          MAJOR_BUMP=false
          MINOR_BUMP=false
          PATCH_BUMP=false
          
          while IFS= read -r commit; do
            if [[ $commit =~ ^(BREAKING CHANGE:|feat!:|fix!:) ]]; then
              MAJOR_BUMP=true
            elif [[ $commit =~ ^feat ]]; then
              MINOR_BUMP=true
            elif [[ $commit =~ ^(fix|perf|refactor) ]]; then
              PATCH_BUMP=true
            fi
          done <<< "$COMMITS"
          
          # Parse current version
          CURRENT_VERSION=${LAST_TAG#v}
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Calculate new version
          if [ "$MAJOR_BUMP" = true ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$MINOR_BUMP" = true ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi
          
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ New version: v$NEW_VERSION"
          
      - name: ðŸ”¨ Build with Maven
        working-directory: ./${{ inputs.service_name }}
        run: |
          mvn clean compile -DskipTests
          
      - name: ðŸ§ª Run Unit Tests
        working-directory: ./${{ inputs.service_name }}
        run: |
          mvn test
          
      - name: ðŸ“Š Generate Test Coverage Report
        working-directory: ./${{ inputs.service_name }}
        run: |
          mvn jacoco:report
          
      - name: ðŸ“¤ Upload Test Results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results-${{ inputs.service_name }}
          path: ./${{ inputs.service_name }}/target/surefire-reports/
          
      - name: ðŸ“¤ Upload Coverage Report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report-${{ inputs.service_name }}
          path: ./${{ inputs.service_name }}/target/site/jacoco/
          
      - name: ðŸ“¦ Package Application
        working-directory: ./${{ inputs.service_name }}
        run: |
          mvn package -DskipTests
          
      - name: ðŸ“¤ Upload JAR Artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ inputs.service_name }}-${{ steps.semantic-version.outputs.version }}.jar
          path: ./${{ inputs.service_name }}/target/*.jar

  # ============================================
  # JOB 2: SONARQUBE ANALYSIS
  # ============================================
  sonarqube-analysis:
    name: ðŸ” SonarQube Analysis
    runs-on: ubuntu-latest
    needs: build-and-test
    if: ${{ secrets.SONAR_TOKEN != '' }}
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: â˜• Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'
          
      - name: ðŸ“Š SonarQube Scan
        working-directory: ./${{ inputs.service_name }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io
        run: |
          mvn sonar:sonar \
            -Dsonar.projectKey=${{ github.repository_owner }}_${{ inputs.service_name }} \
            -Dsonar.organization=${{ github.repository_owner }} \
            -Dsonar.host.url=$SONAR_HOST_URL \
            -Dsonar.login=$SONAR_TOKEN \
            -Dsonar.java.coveragePlugin=jacoco \
            -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml
            
      - name: ðŸš¨ Quality Gate Check
        uses: sonarsource/sonarqube-quality-gate-action@master
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        continue-on-error: true

  # ============================================
  # JOB 3: BUILD DOCKER IMAGE & TRIVY SCAN
  # ============================================
  build-docker-and-scan:
    name: ðŸ³ Build Docker & Security Scan
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        
      - name: ðŸ“¥ Download JAR artifact
        uses: actions/download-artifact@v3
        with:
          name: ${{ inputs.service_name }}-${{ needs.build-and-test.outputs.version }}.jar
          path: ./${{ inputs.service_name }}/target/
          
      - name: ðŸ” Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}
          
      - name: ðŸ—ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: ðŸ³ Build Docker Image
        working-directory: ./${{ inputs.service_name }}
        run: |
          docker build \
            -t ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:${{ needs.build-and-test.outputs.version }} \
            -t ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:latest \
            -t ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:${{ inputs.environment }} \
            --label "version=${{ needs.build-and-test.outputs.version }}" \
            --label "commit=${{ github.sha }}" \
            --label "build-date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            .
            
      - name: ðŸ”’ Trivy - Scan Docker Image for Vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:${{ needs.build-and-test.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'  # Don't fail the build, just report
          
      - name: ðŸ“¤ Upload Trivy Results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          
      - name: ðŸ“Š Generate Trivy Report (Table)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:${{ needs.build-and-test.outputs.version }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
          
      - name: ðŸš€ Push Docker Image to ACR
        run: |
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:${{ needs.build-and-test.outputs.version }}
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:latest
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:${{ inputs.environment }}
          
      - name: ðŸ·ï¸ Create Git Tag
        if: inputs.environment == 'production'
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git tag -a v${{ needs.build-and-test.outputs.version }} -m "Release v${{ needs.build-and-test.outputs.version }} for ${{ inputs.service_name }}"
          git push origin v${{ needs.build-and-test.outputs.version }}

  # ============================================
  # JOB 4: DEPLOY TO KUBERNETES
  # ============================================
  deploy-to-kubernetes:
    name: ðŸš€ Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    needs: [build-and-test, build-docker-and-scan]
    environment:
      name: ${{ inputs.environment }}
      url: ${{ steps.get-url.outputs.url }}
    
    steps:
      - name: ðŸ“¥ Checkout Infrastructure Repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/ecommerce-microservice-Infraestructura
          token: ${{ github.token }}
          path: infra
          
      - name: ðŸ” Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
          
      - name: ðŸ” Configure kubectl with kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
      - name: ðŸ”„ Update Kubernetes Manifest
        working-directory: infra/k8s/services
        run: |
          SERVICE_FILE=$(ls | grep "${{ inputs.service_name }}.yaml")
          
          # Update image version
          sed -i "s|image:.*${{ inputs.service_name }}:.*|image: ${{ secrets.ACR_LOGIN_SERVER }}/${{ inputs.service_name }}:${{ needs.build-and-test.outputs.version }}|g" $SERVICE_FILE
          
          # Update version label
          sed -i "s|version: .*|version: \"${{ needs.build-and-test.outputs.version }}\"|g" $SERVICE_FILE
          
          echo "ðŸ“ Updated manifest:"
          cat $SERVICE_FILE | grep -A 2 "image:"
          
      - name: ðŸš€ Deploy to Kubernetes (${{ inputs.environment }} namespace)
        working-directory: infra/k8s/services
        run: |
          kubectl apply -f $(ls | grep "${{ inputs.service_name }}.yaml") -n ${{ inputs.environment }}
          
      - name: â³ Wait for Rollout
        run: |
          kubectl rollout status deployment/${{ inputs.service_name }} -n ${{ inputs.environment }} --timeout=5m
          
      - name: âœ… Verify Deployment
        id: verify
        run: |
          # Check if pods are running
          READY_PODS=$(kubectl get deployment ${{ inputs.service_name }} -n ${{ inputs.environment }} -o jsonpath='{.status.readyReplicas}')
          DESIRED_PODS=$(kubectl get deployment ${{ inputs.service_name }} -n ${{ inputs.environment }} -o jsonpath='{.spec.replicas}')
          
          echo "Ready Pods: $READY_PODS / $DESIRED_PODS"
          
          if [ "$READY_PODS" != "$DESIRED_PODS" ]; then
            echo "âŒ Deployment verification failed!"
            exit 1
          fi
          
          echo "âœ… Deployment successful: $READY_PODS/$DESIRED_PODS pods ready"
          
      - name: ðŸ” Get Service URL
        id: get-url
        run: |
          SERVICE_IP=$(kubectl get svc ${{ inputs.service_name }} -n ${{ inputs.environment }} -o jsonpath='{.spec.clusterIP}')
          echo "url=http://$SERVICE_IP:${{ inputs.service_port }}${{ inputs.context_path }}" >> $GITHUB_OUTPUT
          echo "ðŸŒ Service URL: http://$SERVICE_IP:${{ inputs.service_port }}${{ inputs.context_path }}"
          
      - name: ðŸ§ª Health Check
        run: |
          # Port-forward for health check
          kubectl port-forward svc/${{ inputs.service_name }} ${{ inputs.service_port }}:${{ inputs.service_port }} -n ${{ inputs.environment }} &
          PF_PID=$!
          sleep 5
          
          # Health check with Basic Auth (admin:admin)
          HEALTH_URL="http://localhost:${{ inputs.service_port }}${{ inputs.context_path }}/actuator/health"
          echo "ðŸ¥ Checking health: $HEALTH_URL"
          
          RESPONSE=$(curl -s -u admin:admin -w "\n%{http_code}" $HEALTH_URL || echo "000")
          HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)
          
          kill $PF_PID 2>/dev/null || true
          
          if [ "$HTTP_CODE" == "200" ]; then
            echo "âœ… Health check passed"
          else
            echo "âš ï¸ Health check returned: $HTTP_CODE (may need time to warm up)"
          fi

  # ============================================
  # JOB 5: SMOKE TESTS
  # ============================================
  smoke-tests:
    name: ðŸ§ª Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy-to-kubernetes
    if: inputs.environment != 'production'
    
    steps:
      - name: ðŸ” Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
      - name: ðŸ§ª Run Smoke Tests
        run: |
          echo "ðŸ§ª Running smoke tests for ${{ inputs.service_name }}..."
          
          # Test 1: Pod is running
          POD_STATUS=$(kubectl get pods -n ${{ inputs.environment }} -l app=${{ inputs.service_name }} -o jsonpath='{.items[0].status.phase}')
          if [ "$POD_STATUS" != "Running" ]; then
            echo "âŒ Pod is not running: $POD_STATUS"
            exit 1
          fi
          echo "âœ… Pod is running"
          
          # Test 2: Service is accessible
          kubectl port-forward svc/${{ inputs.service_name }} ${{ inputs.service_port }}:${{ inputs.service_port }} -n ${{ inputs.environment }} &
          PF_PID=$!
          sleep 5
          
          HEALTH_RESPONSE=$(curl -s -u admin:admin http://localhost:${{ inputs.service_port }}${{ inputs.context_path }}/actuator/health || echo '{"status":"DOWN"}')
          
          kill $PF_PID 2>/dev/null || true
          
          if echo "$HEALTH_RESPONSE" | grep -q '"status":"UP"'; then
            echo "âœ… Service is healthy"
          else
            echo "âŒ Service health check failed: $HEALTH_RESPONSE"
            exit 1
          fi
          
          # Test 3: Service registered in Eureka (if not service-discovery itself)
          if [ "${{ inputs.service_name }}" != "service-discovery" ]; then
            echo "ðŸ” Checking Eureka registration..."
            kubectl port-forward svc/service-discovery 8761:8761 -n ${{ inputs.environment }} &
            EUREKA_PID=$!
            sleep 5
            
            EUREKA_APPS=$(curl -s http://localhost:8761/eureka/apps || echo "")
            
            kill $EUREKA_PID 2>/dev/null || true
            
            SERVICE_UPPER=$(echo "${{ inputs.service_name }}" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
            if echo "$EUREKA_APPS" | grep -q "$SERVICE_UPPER"; then
              echo "âœ… Service registered in Eureka"
            else
              echo "âš ï¸ Service not yet registered in Eureka (may need more time)"
            fi
          fi
          
          echo "âœ… All smoke tests passed!"

  # ============================================
  # JOB 6: ROLLBACK ON FAILURE
  # ============================================
  rollback-on-failure:
    name: ðŸ”™ Rollback
    runs-on: ubuntu-latest
    needs: [deploy-to-kubernetes, smoke-tests]
    if: failure() && inputs.environment == 'production'
    
    steps:
      - name: ðŸ” Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          
      - name: ðŸ”™ Rollback Deployment
        run: |
          echo "ðŸ”™ Rolling back deployment for ${{ inputs.service_name }}..."
          kubectl rollout undo deployment/${{ inputs.service_name }} -n ${{ inputs.environment }}
          kubectl rollout status deployment/${{ inputs.service_name }} -n ${{ inputs.environment }}
          echo "âœ… Rollback completed"

  # ============================================
  # JOB 7: NOTIFICATIONS
  # ============================================
  notify:
    name: ðŸ“¢ Send Notifications
    runs-on: ubuntu-latest
    needs: [build-and-test, build-docker-and-scan, deploy-to-kubernetes, smoke-tests]
    if: always()
    
    steps:
      - name: ðŸ“Š Determine Status
        id: status
        run: |
          if [ "${{ needs.deploy-to-kubernetes.result }}" == "success" ] && [ "${{ needs.smoke-tests.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=âœ…" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=âŒ" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          fi
          
      - name: ðŸ“¢ Slack Notification
        if: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "${{ steps.status.outputs.emoji }} CI/CD Pipeline - ${{ inputs.service_name }}",
              "attachments": [{
                "color": "${{ steps.status.outputs.color }}",
                "fields": [
                  { "title": "Service", "value": "${{ inputs.service_name }}", "short": true },
                  { "title": "Environment", "value": "${{ inputs.environment }}", "short": true },
                  { "title": "Version", "value": "${{ needs.build-and-test.outputs.version }}", "short": true },
                  { "title": "Status", "value": "${{ steps.status.outputs.status }}", "short": true },
                  { "title": "Commit", "value": "${{ github.sha }}", "short": true },
                  { "title": "Author", "value": "${{ github.actor }}", "short": true }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
